/**
 * ============================================================================
 * PANOPTICON FOUNDATION SCRIPT
 * ============================================================================
 * Minimal working foundation - build from here
 * Version: 1.0
 * Date: 2025-10-22
 */

// ============================================================================
// CONFIGURATION - SINGLE SOURCE OF TRUTH
// ============================================================================

const CONFIG = {
  // Sheet Names
  SHEETS: {
    FRC: 'FRC',  // Form Responses (Clean) - your main data
    MASTER_DESC: 'Master_Desc',
    PAN_LOG: 'Pan_Log',
    TOOL_REGISTRY: 'Tool_Registry',
    DATA_DICT: 'Data_Dictionary'
  },
  
  // FRC Column Indices (0-based for arrays)
  COL: {
    TIMESTAMP: 0,
    BIRTHDAY: 1,
    ZODIAC: 2,
    AGE: 3,
    EDU: 4,
    ZIP: 5,
    ETHNICITY: 6,
    GENDER: 7,
    ORIENTATION: 8,
    INDUSTRY: 9,
    ROLE: 10,
    KNOW_HOSTS: 11,
    KNOWN_LONGEST: 12,
    KNOW_SCORE: 13,
    INTERESTS_RAW: 14,
    INTEREST_1: 15,
    INTEREST_2: 16,
    INTEREST_3: 17,
    MUSIC: 18,
    ARTIST: 19,
    SONG: 20,
    RECENT_PURCHASE: 21,
    AT_WORST: 22,
    SOCIAL_STANCE: 23,
    SCREEN_NAME: 24,
    UID: 25,
    DDD_SCORE: 26,
    CHECKED_IN: 27,
    CHECKIN_TIME: 28,
    PHOTO_URL: 29
  },
  
  // Drive Folder ID for photos
  PHOTO_FOLDER_ID: '1ZcP5jpYsYy0xuGqlFYNrDgG4K40eEKJB'
};

// ============================================================================
// MENU SYSTEM
// ============================================================================

/**
 * Creates custom menu when spreadsheet opens
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  
  ui.createMenu('üé≠ Panopticon')
    .addItem('üé¨ Display Carousel (Auto-Rotate)', 'openCarousel')
    .addItem('üìä View Display Dashboard', 'openDisplay')
    .addSeparator()
    .addItem('üß± The Wall Display', 'openWall')
    .addItem('üéÉ Compatibility Matcher (MM)', 'openMM')
    .addSeparator()
    .addItem('‚úÖ Open Check-In Interface', 'openCheckIn')
    .addItem('üß™ Test Check-In System', 'testCheckInSystem')
    .addSeparator()
    .addItem('üßÆ Test Compatibility Matches', 'testCompatibilityMatches')
    .addSeparator()
    .addItem('üìà Generate Master Description', 'generateMasterDesc')
    .addItem('üîç View Tool Registry', 'viewToolRegistry')
    .addSeparator()
    .addItem('üöÄ Deploy Web App', 'showDeployInstructions')
    .addToUi();
  
  Logger.log('‚úÖ Panopticon menu created');
}

// ============================================================================
// WEB APP ROUTER
// ============================================================================

/**
 * Main routing function for web app
 */
function doGet(e) {
  if (!e || !e.parameter) { 
    e = { parameter: {} }; 
  }
  
  const page = (e.parameter.page || 'display').toLowerCase();
  
  try {
    switch(page) {
      case 'checkin':
        return HtmlService.createTemplateFromFile('CheckInInterface')
          .evaluate()
          .setTitle('Guest Check-In')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
      
      case 'wall':
        return HtmlService.createTemplateFromFile('Wall')
          .evaluate()
          .setTitle('The Wall - Panopticon')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
      
      case 'test':
        return HtmlService.createTemplateFromFile('TestCheckIn')
          .evaluate()
          .setTitle('Check-In Test')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);

      case 'mm':
        return HtmlService.createTemplateFromFile('MM')
          .evaluate()
          .setTitle('Compatibility Matcher - MM')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);

      case 'map':
        return HtmlService.createTemplateFromFile('MapDisplay')
          .evaluate()
          .setTitle('Guest Routes Map - Panopticon')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);

      case 'carousel':
      case 'display':
      default:
        return HtmlService.createTemplateFromFile('Carousel')
          .evaluate()
          .setTitle('Display Carousel - Panopticon')
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    }
  } catch (error) {
    return createErrorPage(error);
  }
}

/**
 * Creates a simple display page
 */
function createSimpleDisplay() {
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <base target="_top">
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0;
          padding: 20px;
        }
        .container {
          background: white;
          border-radius: 20px;
          padding: 40px;
          max-width: 600px;
          box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { color: #333; margin-bottom: 20px; }
        p { color: #666; line-height: 1.6; }
        .status { 
          background: #d4edda; 
          color: #155724; 
          padding: 15px; 
          border-radius: 10px;
          margin-top: 20px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>üé≠ Panopticon System</h1>
        <p>Welcome to the Panopticon Guest Analytics System.</p>
        <div class="status">
          ‚úÖ System Status: Online<br>
          üìä Foundation Layer: Active<br>
          üîß Ready for expansion
        </div>
      </div>
    </body>
    </html>
  `;
  
  return HtmlService.createHtmlOutput(html)
    .setTitle('Panopticon Display')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Gets the FRC sheet
 */
function getFRCSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(CONFIG.SHEETS.FRC);
  
  if (!sheet) {
    // Try alternative names
    const altSheet = ss.getSheetByName('Form Responses (Clean)');
    if (altSheet) {
      Logger.log('‚ö†Ô∏è Found "Form Responses (Clean)" - please rename to "FRC"');
      return altSheet;
    }
    
    const availableSheets = ss.getSheets().map(s => s.getName()).join(', ');
    throw new Error('FRC sheet not found. Available sheets: ' + availableSheets + '. Please rename your sheet to "FRC"');
  }
  
  return sheet;
}

/**
 * Debug function - lists all sheets in the spreadsheet
 */
function listAllSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();
  
  Logger.log('=== ALL SHEETS IN SPREADSHEET ===');
  sheets.forEach((sheet, index) => {
    Logger.log(`${index + 1}. "${sheet.getName()}" (${sheet.getLastRow()} rows)`);
  });
  
  const ui = SpreadsheetApp.getUi();
  ui.alert(
    'Sheet List',
    'Found ' + sheets.length + ' sheets:\n\n' + 
    sheets.map((s, i) => `${i+1}. ${s.getName()}`).join('\n'),
    ui.ButtonSet.OK
  );
}

/**
 * Gets all checked-in guests from FRC
 */
function getCheckedInGuests() {
  const sheet = getFRCSheet();
  const data = sheet.getDataRange().getValues();
  
  const guests = [];
  
  // Skip header row (index 0)
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const checkedIn = String(row[CONFIG.COL.CHECKED_IN] || '').trim();
    
    // Only include guests with "Y" in Checked-In column
    if (checkedIn === 'Y' || checkedIn === 'Yes') {
      guests.push({
        rowIndex: i,
        timestamp: row[CONFIG.COL.TIMESTAMP],
        birthday: row[CONFIG.COL.BIRTHDAY],
        zodiac: row[CONFIG.COL.ZODIAC],
        age: row[CONFIG.COL.AGE],
        education: row[CONFIG.COL.EDU],
        zip: row[CONFIG.COL.ZIP],
        ethnicity: row[CONFIG.COL.ETHNICITY],
        gender: row[CONFIG.COL.GENDER],
        orientation: row[CONFIG.COL.ORIENTATION],
        industry: row[CONFIG.COL.INDUSTRY],
        role: row[CONFIG.COL.ROLE],
        knowHosts: row[CONFIG.COL.KNOW_HOSTS],
        knownLongest: row[CONFIG.COL.KNOWN_LONGEST],
        knowScore: row[CONFIG.COL.KNOW_SCORE],
        interestsRaw: row[CONFIG.COL.INTERESTS_RAW],
        interest1: row[CONFIG.COL.INTEREST_1],
        interest2: row[CONFIG.COL.INTEREST_2],
        interest3: row[CONFIG.COL.INTEREST_3],
        music: row[CONFIG.COL.MUSIC],
        artist: row[CONFIG.COL.ARTIST],
        song: row[CONFIG.COL.SONG],
        recentPurchase: row[CONFIG.COL.RECENT_PURCHASE],
        atWorst: row[CONFIG.COL.AT_WORST],
        socialStance: row[CONFIG.COL.SOCIAL_STANCE],
        screenName: row[CONFIG.COL.SCREEN_NAME],
        uid: row[CONFIG.COL.UID],
        dddScore: row[CONFIG.COL.DDD_SCORE],
        checkedIn: row[CONFIG.COL.CHECKED_IN],
        checkInTime: row[CONFIG.COL.CHECKIN_TIME],
        photoUrl: row[CONFIG.COL.PHOTO_URL]
      });
    }
  }
  
  Logger.log(`‚úÖ Found ${guests.length} checked-in guests`);
  return guests;
}

/**
 * Creates error page
 */
function createErrorPage(error) {
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body {
          font-family: monospace;
          background: #1a1a1a;
          color: #ff6b6b;
          padding: 40px;
        }
        .error {
          background: #2d2d2d;
          border: 2px solid #ff6b6b;
          border-radius: 10px;
          padding: 20px;
          max-width: 800px;
          margin: 0 auto;
        }
        h1 { color: #ff6b6b; }
        pre { 
          background: #1a1a1a; 
          padding: 15px; 
          border-radius: 5px;
          overflow-x: auto;
        }
      </style>
    </head>
    <body>
      <div class="error">
        <h1>‚ùå System Error</h1>
        <p><strong>Message:</strong> ${error.message}</p>
        <pre>${error.stack || 'No stack trace available'}</pre>
      </div>
    </body>
    </html>
  `;
  
  return HtmlService.createHtmlOutput(html)
    .setTitle('Error')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

// ============================================================================
// MENU HANDLERS
// ============================================================================

function openDisplay() {
  const url = ScriptApp.getService().getUrl();
  const html = `
    <html>
      <body>
        <p>Open this URL in a new tab:</p>
        <p><a href="${url}" target="_blank">${url}</a></p>
        <script>
          window.open('${url}', '_blank');
          google.script.host.close();
        </script>
      </body>
    </html>
  `;
  SpreadsheetApp.getUi().showModalDialog(
    HtmlService.createHtmlOutput(html).setWidth(400).setHeight(150),
    'Display Dashboard'
  );
}

function openCheckIn() {
  const url = ScriptApp.getService().getUrl() + '?page=checkin';
  const html = `
    <html>
      <body>
        <p>Open this URL in a new tab:</p>
        <p><a href="${url}" target="_blank">${url}</a></p>
        <script>
          window.open('${url}', '_blank');
          google.script.host.close();
        </script>
      </body>
    </html>
  `;
  SpreadsheetApp.getUi().showModalDialog(
    HtmlService.createHtmlOutput(html).setWidth(400).setHeight(150),
    'Check-In Interface'
  );
}

function openMM() {
  const url = ScriptApp.getService().getUrl() + '?page=mm';
  const html = `
    <html>
      <body>
        <p>Open this URL in a new tab:</p>
        <p><a href="${url}" target="_blank">${url}</a></p>
        <script>
          window.open('${url}', '_blank');
          google.script.host.close();
        </script>
      </body>
    </html>
  `;
  SpreadsheetApp.getUi().showModalDialog(
    HtmlService.createHtmlOutput(html).setWidth(400).setHeight(150),
    'Compatibility Matcher (MM)'
  );
}

function openWall() {
  const url = ScriptApp.getService().getUrl() + '?page=wall';
  const html = `
    <html>
      <body>
        <p>Open this URL in a new tab:</p>
        <p><a href="${url}" target="_blank">${url}</a></p>
        <script>
          window.open('${url}', '_blank');
          google.script.host.close();
        </script>
      </body>
    </html>
  `;
  SpreadsheetApp.getUi().showModalDialog(
    HtmlService.createHtmlOutput(html).setWidth(400).setHeight(150),
    'The Wall Display'
  );
}

function openCarousel() {
  const url = ScriptApp.getService().getUrl() + '?page=carousel';
  const html = `
    <html>
      <body>
        <p>Open this URL in a new tab:</p>
        <p><a href="${url}" target="_blank">${url}</a></p>
        <script>
          window.open('${url}', '_blank');
          google.script.host.close();
        </script>
      </body>
    </html>
  `;
  SpreadsheetApp.getUi().showModalDialog(
    HtmlService.createHtmlOutput(html).setWidth(400).setHeight(150),
    'Display Carousel'
  );
}

function showDeployInstructions() {
  const ui = SpreadsheetApp.getUi();
  ui.alert(
    'Deploy as Web App',
    'To deploy:\n\n' +
    '1. Click "Deploy" ‚Üí "New deployment"\n' +
    '2. Type: Web app\n' +
    '3. Execute as: Me\n' +
    '4. Who has access: Anyone (or your preference)\n' +
    '5. Click "Deploy"\n' +
    '6. Copy the web app URL\n\n' +
    'The URL will work for both display and check-in pages.',
    ui.ButtonSet.OK
  );
}

function testCheckInSystem() {
  try {
    const guests = getCheckedInGuests();
    
    // Check if we're in UI context or web app context
    try {
      const ui = SpreadsheetApp.getUi();
      // We're in UI context - show alert
      ui.alert(
        '‚úÖ Check-In System Test',
        `Found ${guests.length} checked-in guests.\n\n` +
        (guests.length > 0 ? 
          `Sample guest:\n` +
          `- Screen Name: ${guests[0].screenName}\n` +
          `- UID: ${guests[0].uid}\n` +
          `- Check-in Time: ${guests[0].checkInTime}\n` +
          `- Photo: ${guests[0].photoUrl ? 'Yes' : 'No'}` 
          : 'No checked-in guests found.'),
        ui.ButtonSet.OK
      );
    } catch (uiError) {
      // We're in web app context - just log and return result
      Logger.log('‚úÖ Check-In System Test');
      Logger.log(`Found ${guests.length} checked-in guests`);
      if (guests.length > 0) {
        Logger.log('Sample guest: ' + JSON.stringify(guests[0], null, 2));
      }
      
      return {
        ok: true,
        guestCount: guests.length,
        sampleGuest: guests.length > 0 ? guests[0] : null
      };
    }
  } catch (error) {
    Logger.log('‚ùå Error: ' + error.message);
    
    try {
      SpreadsheetApp.getUi().alert('Error: ' + error.message);
    } catch (e) {
      return {ok: false, error: error.message};
    }
  }
}

/**
 * Test function to verify backend connectivity
 * Returns a simple object to confirm functions are accessible
 */
function testConnection() {
  return {
    status: 'ok',
    message: 'Backend is connected!',
    timestamp: new Date().toISOString()
  };
}

/**
 * Simplest possible test - returns a string
 */
function ping() {
  return "pong";
}

/**
 * Test with spreadsheet access
 */
function testSpreadsheetAccess() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    return {
      ok: true,
      spreadsheetName: ss.getName(),
      sheetCount: ss.getSheets().length
    };
  } catch (error) {
    return {
      ok: false,
      error: error.toString()
    };
  }
}

/**
 * Manual test of check-in with sample data
 * Replace with real values from your FRC sheet
 */
function testCheckInManually() {
  // TODO: Replace these with actual values from your FRC sheet
  const result = checkInGuest({
    zip: '12345',      // Replace with real ZIP
    gender: 'man',     // Replace with real gender
    dob: '03/15'       // Replace with real birthday
  });
  
  Logger.log('Check-in test result:');
  Logger.log(JSON.stringify(result, null, 2));
  
  SpreadsheetApp.getUi().alert(
    'Check-In Test Result',
    JSON.stringify(result, null, 2),
    SpreadsheetApp.getUi().ButtonSet.OK
  );
}

// ============================================================================
// DOCUMENTATION FUNCTIONS (to be expanded)
// ============================================================================

function generateMasterDesc() {
  SpreadsheetApp.getUi().alert(
    'üìä Master Description',
    'This feature will generate comprehensive documentation of all sheets.\n\n' +
    'Coming in next build phase...',
    SpreadsheetApp.getUi().ButtonSet.OK
  );
}

function viewToolRegistry() {
  SpreadsheetApp.getUi().alert(
    'üîç Tool Registry',
    'This feature will show all function executions and lineage.\n\n' +
    'Coming in next build phase...',
    SpreadsheetApp.getUi().ButtonSet.OK
  );
}

// ============================================================================
// PHASE 2: CHECK-IN FUNCTIONS
// ============================================================================

/**
 * Check in guest using ZIP, Gender, and Birthday
 * Called from CheckInInterface.html
 * 
 * Can accept either:
 * 1. Three separate parameters: checkInGuest(zip, gender, dob)
 * 2. One object parameter: checkInGuest({zip, gender, dob})
 */
function checkInGuest(zipOrPayload, gender, dob) {
  Logger.log('=== CHECK-IN STARTED ===');
  Logger.log('Arguments received:');
  Logger.log('  Arg 0 (zipOrPayload): ' + JSON.stringify(zipOrPayload));
  Logger.log('  Arg 1 (gender): ' + gender);
  Logger.log('  Arg 2 (dob): ' + dob);
  Logger.log('  Total arguments: ' + arguments.length);
  
  let zipCode, genderValue, birthday;
  
  try {
    // Determine if we got an object or separate parameters
    if (arguments.length === 3) {
      // Called with separate parameters: checkInGuest(zip, gender, dob)
      zipCode = String(zipOrPayload || '').trim();
      genderValue = String(gender || '').trim();
      birthday = String(dob || '').trim();
      Logger.log('üìå Using separate parameters mode');
    } else if (arguments.length === 1 && typeof zipOrPayload === 'object' && zipOrPayload !== null) {
      // Called with object: checkInGuest({zip, gender, dob})
      zipCode = String(zipOrPayload.zip || '').trim();
      genderValue = String(zipOrPayload.gender || '').trim();
      birthday = String(zipOrPayload.dob || '').trim();
      Logger.log('üìå Using object parameter mode');
    } else {
      Logger.log('‚ùå ERROR: Invalid parameters');
      return {
        ok: false,
        message: 'Invalid request format. Please try again.'
      };
    }
    
    Logger.log(`‚úÖ Extracted values: ZIP="${zipCode}", Gender="${genderValue}", DOB="${birthday}"`);
    
    if (!zipCode || !genderValue || !birthday) {
      Logger.log('‚ùå Missing required fields');
      return {
        ok: false,
        message: 'Missing required fields: ZIP code, gender, and birthday are required'
      };
    }
    
    const sheet = getFRCSheet();
    const data = sheet.getDataRange().getValues();
    
    Logger.log(`üìä Sheet has ${data.length} rows`);
    
    // Normalize birthday with leading zeros (e.g., 3/5 -> 03/05)
    const birthdayParts = birthday.split('/');
    let normalizedBirthday;
    if (birthdayParts.length >= 2) {
      const month = parseInt(birthdayParts[0], 10);
      const day = parseInt(birthdayParts[1], 10);
      normalizedBirthday = String(month).padStart(2, '0') + '/' + String(day).padStart(2, '0');
    } else {
      normalizedBirthday = birthday;
    }
    
    Logger.log(`üîç Searching for: ZIP="${zipCode}", Gender="${genderValue}", Birthday="${normalizedBirthday}"`);
    
    // Search for matching guest (skip header row)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const rowBirthdayRaw = row[CONFIG.COL.BIRTHDAY];
      const rowZip = String(row[CONFIG.COL.ZIP] || '').trim();
      const rowGender = String(row[CONFIG.COL.GENDER] || '').trim();
      const rowScreenName = String(row[CONFIG.COL.SCREEN_NAME] || '').trim();
      const rowUID = String(row[CONFIG.COL.UID] || '').trim();
      
      // Normalize row birthday (handle both Date objects and strings)
      let normalizedRowBirthday;
      if (rowBirthdayRaw instanceof Date) {
        const month = rowBirthdayRaw.getMonth() + 1;
        const day = rowBirthdayRaw.getDate();
        normalizedRowBirthday = String(month).padStart(2, '0') + '/' + String(day).padStart(2, '0');
      } else {
        const rowBirthday = String(rowBirthdayRaw || '').trim();
        const rowParts = rowBirthday.split('/');
        if (rowParts.length >= 2) {
          const month = parseInt(rowParts[0], 10);
          const day = parseInt(rowParts[1], 10);
          normalizedRowBirthday = String(month).padStart(2, '0') + '/' + String(day).padStart(2, '0');
        } else {
          normalizedRowBirthday = rowBirthday;
        }
      }
      
      // Check for match
      if (rowZip === zipCode && 
          rowGender.toLowerCase() === genderValue.toLowerCase() && 
          normalizedRowBirthday === normalizedBirthday) {
        
        Logger.log(`‚úÖ MATCH FOUND at row ${i+1}: ${rowScreenName} (${rowUID})`);
        
        // Check if already checked in
        const alreadyCheckedIn = String(row[CONFIG.COL.CHECKED_IN] || '').trim();
        
        if (alreadyCheckedIn === 'Y' || alreadyCheckedIn === 'Yes') {
          const existingTime = row[CONFIG.COL.CHECKIN_TIME];
          Logger.log('‚ö†Ô∏è Guest already checked in at: ' + existingTime);
          
          return {
            ok: true,
            message: 'Welcome back! You were already checked in.',
            screenName: rowScreenName,
            uid: rowUID,
            alreadyCheckedIn: true,
            checkInTime: existingTime,
            photoUrl: row[CONFIG.COL.PHOTO_URL] || ''
          };
        }
        
        // Perform check-in
        const checkInTime = new Date();
        const targetRow = i + 1; // Convert to 1-indexed
        
        Logger.log(`üìù Checking in at row ${targetRow}...`);
        
        // Write check-in data (Column AB = 28, Column AC = 29)
        sheet.getRange(targetRow, CONFIG.COL.CHECKED_IN + 1).setValue('Y');
        sheet.getRange(targetRow, CONFIG.COL.CHECKIN_TIME + 1).setValue(checkInTime);
        SpreadsheetApp.flush();
        
        Logger.log(`‚úÖ Check-in successful: ${rowScreenName}`);
        
        return {
          ok: true,
          message: 'Check-in successful! Welcome, ' + rowScreenName + '!',
          screenName: rowScreenName,
          uid: rowUID,
          alreadyCheckedIn: false,
          checkInTime: checkInTime.toLocaleString(),
          photoUrl: row[CONFIG.COL.PHOTO_URL] || ''
        };
      }
    }
    
    // No match found
    Logger.log('‚ùå No matching guest found');
    Logger.log(`Searched ${data.length - 1} guest records`);
    return {
      ok: false,
      message: 'Guest not found. Please verify your ZIP code, gender, and birthday match your registration.'
    };
    
  } catch (error) {
    Logger.log('‚ùå ERROR: ' + error.toString());
    Logger.log('Stack: ' + error.stack);
    return {
      ok: false,
      message: 'System error: ' + error.message
    };
  }
}

/**
 * Update a guest's screen name
 * Called from CheckInInterface.html
 * 
 * Can accept either:
 * 1. Two separate parameters: updateGuestScreenName(uid, newScreenName)
 * 2. One object parameter: updateGuestScreenName({uid, newScreenName})
 */
function updateGuestScreenName(uidOrPayload, newScreenName) {
  Logger.log('=== UPDATE SCREEN NAME ===');
  Logger.log('Arguments: ' + JSON.stringify(arguments));
  
  let uid, screenName;
  
  try {
    if (arguments.length === 2) {
      // Separate parameters
      uid = String(uidOrPayload || '').trim();
      screenName = String(newScreenName || '').trim();
    } else if (arguments.length === 1 && typeof uidOrPayload === 'object') {
      // Object parameter
      uid = String(uidOrPayload.uid || '').trim();
      screenName = String(uidOrPayload.newScreenName || '').trim();
    } else {
      return {ok: false, message: 'Invalid parameters'};
    }
    
    if (!uid || !screenName) {
      return {
        ok: false,
        message: 'UID and new screen name are required'
      };
    }
    
    if (screenName.length < 3 || screenName.length > 50) {
      return {
        ok: false,
        message: 'Screen name must be 3-50 characters'
      };
    }
    
    const sheet = getFRCSheet();
    const data = sheet.getDataRange().getValues();
    
    // Find guest by UID
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][CONFIG.COL.UID] || '').trim() === uid) {
        const targetRow = i + 1;
        
        Logger.log(`Updating screen name for row ${targetRow}`);
        
        // Update Column Y (Screen Name) - add 1 for 1-indexed
        sheet.getRange(targetRow, CONFIG.COL.SCREEN_NAME + 1).setValue(screenName);
        SpreadsheetApp.flush();
        
        Logger.log(`‚úì Screen name updated to: ${screenName}`);
        
        return {
          ok: true,
          message: 'Screen name updated successfully!',
          newScreenName: screenName
        };
      }
    }
    
    return {ok: false, message: 'Guest not found'};
    
  } catch (error) {
    Logger.log('‚ùå ERROR: ' + error.toString());
    return {ok: false, message: 'Update failed: ' + error.message};
  }
}

/**
 * Upload guest photo to Google Drive
 * Called from CheckInInterface.html
 * 
 * Can accept either:
 * 1. Four separate parameters: uploadGuestPhoto(uid, fileName, mimeType, base64Data)
 * 2. One object parameter: uploadGuestPhoto({uid, fileName, mimeType, base64Data})
 */
function uploadGuestPhoto(uidOrPayload, fileName, mimeType, base64Data) {
  Logger.log('=== PHOTO UPLOAD ===');
  
  let uid, name, mime, data;
  
  try {
    if (arguments.length === 4) {
      // Separate parameters
      uid = uidOrPayload;
      name = fileName;
      mime = mimeType;
      data = base64Data;
    } else if (arguments.length === 1 && typeof uidOrPayload === 'object') {
      // Object parameter
      uid = uidOrPayload.uid;
      name = uidOrPayload.fileName;
      mime = uidOrPayload.mimeType;
      data = uidOrPayload.base64Data;
    } else {
      return {ok: false, message: 'Invalid parameters'};
    }
    
    if (!uid || !name || !mime || !data) {
      return {ok: false, message: 'Missing required upload parameters'};
    }
    
    if (!mime.startsWith('image/')) {
      return {ok: false, message: 'Only image files are allowed'};
    }
    
    // Get or create Guest Photos folder
    let folder;
    try {
      folder = DriveApp.getFolderById(CONFIG.PHOTO_FOLDER_ID);
      Logger.log('Found Guest Photos folder');
    } catch (e) {
      const folders = DriveApp.getFoldersByName('Guest Photos');
      folder = folders.hasNext() ? folders.next() : DriveApp.createFolder('Guest Photos');
      Logger.log('Created Guest Photos folder');
    }
    
    const uniqueFileName = `${uid}_${name}`;
    
    // Delete old photo if exists
    const existingFiles = folder.getFilesByName(uniqueFileName);
    while (existingFiles.hasNext()) {
      existingFiles.next().setTrashed(true);
      Logger.log('Deleted old photo');
    }
    
    // Upload new photo
    const decodedData = Utilities.base64Decode(data);
    const blob = Utilities.newBlob(decodedData, mime, uniqueFileName);
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    const fileUrl = file.getUrl();
    
    Logger.log(`Photo uploaded: ${fileUrl}`);
    
    // Update FRC sheet with photo URL
    const sheet = getFRCSheet();
    const sheetData = sheet.getDataRange().getValues();
    
    for (let i = 1; i < sheetData.length; i++) {
      if (String(sheetData[i][CONFIG.COL.UID] || '').trim() === uid) {
        const targetRow = i + 1;
        sheet.getRange(targetRow, CONFIG.COL.PHOTO_URL + 1).setValue(fileUrl);
        SpreadsheetApp.flush();
        Logger.log(`‚úì Photo URL saved to row ${targetRow}`);
        break;
      }
    }
    
    return {
      ok: true,
      message: 'Photo uploaded successfully!',
      fileUrl: fileUrl
    };
    
  } catch (error) {
    Logger.log('‚ùå ERROR: ' + error.toString());
    return {ok: false, message: 'Upload failed: ' + error.message};
  }
}

// ============================================================================
// PHASE 3: COMPATIBILITY MATCHER (MM) - CRAM√âR'S V ANALYSIS
// ============================================================================

/**
 * TRIGGER SETUP NOTES:
 * =====================
 * To auto-refresh matches, create a time-driven trigger:
 * 1. Go to Extensions ‚Üí Apps Script ‚Üí Triggers
 * 2. Add Trigger ‚Üí getCompatibilityMatches ‚Üí Time-driven ‚Üí Every 15 minutes
 *
 * This will recalculate matches as new guests check in.
 */

/**
 * Get compatibility matches for checked-in guests
 * Called by MM interface (?page=mm)
 *
 * Returns array of match objects with Cram√©r's V scores
 */
function getCompatibilityMatches() {
  Logger.log('=== GENERATING COMPATIBILITY MATCHES ===');

  const guests = getCheckedInGuests();
  Logger.log(`Analyzing ${guests.length} checked-in guests`);

  const matches = [];
  const MIN_CRAMERS_V = 0.60; // Minimum threshold for matches

  // Compare every pair of guests
  for (let i = 0; i < guests.length; i++) {
    for (let j = i + 1; j < guests.length; j++) {
      const guest1 = guests[i];
      const guest2 = guests[j];

      // Calculate compatibility score (Cram√©r's V)
      const result = calculateCompatibilityScore(guest1, guest2);

      // Only include matches above threshold
      if (result.cramersV >= MIN_CRAMERS_V) {
        matches.push({
          person1: {
            screenName: guest1.screenName,
            uid: guest1.uid,
            photoUrl: guest1.photoUrl || '',
            music: guest1.music,
            zodiac: guest1.zodiac,
            interests: [guest1.interest1, guest1.interest2, guest1.interest3].filter(Boolean),
            socialStance: guest1.socialStance,
            atWorst: guest1.atWorst
          },
          person2: {
            screenName: guest2.screenName,
            uid: guest2.uid,
            photoUrl: guest2.photoUrl || '',
            music: guest2.music,
            zodiac: guest2.zodiac,
            interests: [guest2.interest1, guest2.interest2, guest2.interest3].filter(Boolean),
            socialStance: guest2.socialStance,
            atWorst: guest2.atWorst
          },
          similarity: result.cramersV,
          sharedInterests: result.sharedInterests,
          breakdown: result.breakdown
        });
      }
    }
  }

  // Sort by highest compatibility first
  matches.sort((a, b) => b.similarity - a.similarity);

  Logger.log(`‚úÖ Generated ${matches.length} matches above ${MIN_CRAMERS_V} threshold`);

  return {
    matches: matches,
    totalGuests: guests.length,
    timestamp: new Date().toISOString()
  };
}

/**
 * Calculate compatibility score between two guests using Cram√©r's V
 *
 * Weighting:
 * - 40% Interests (shared interests count)
 * - 15% Music (exact match)
 * - 10% Purchase (exact match)
 * - 35% At Worst (same trait match)
 *
 * Returns Cram√©r's V score (0 to 1) plus breakdown
 */
function calculateCompatibilityScore(guest1, guest2) {
  const breakdown = {
    interests: 0,
    music: 0,
    purchase: 0,
    atWorst: 0,
    socialStance: 0
  };

  // 1. INTERESTS MATCHING (40% weight)
  const interests1 = [guest1.interest1, guest1.interest2, guest1.interest3]
    .filter(i => i && i !== 'N/A');
  const interests2 = [guest2.interest1, guest2.interest2, guest2.interest3]
    .filter(i => i && i !== 'N/A');

  const sharedInterests = interests1.filter(i => interests2.includes(i));
  const maxInterests = Math.max(interests1.length, interests2.length);

  if (maxInterests > 0) {
    breakdown.interests = sharedInterests.length / maxInterests;
  }

  // 2. MUSIC MATCHING (15% weight) - Exact match only
  if (guest1.music && guest2.music && guest1.music === guest2.music) {
    breakdown.music = 1.0;
  }

  // 3. PURCHASE MATCHING (10% weight) - Exact match only
  if (guest1.recentPurchase && guest2.recentPurchase &&
      guest1.recentPurchase === guest2.recentPurchase) {
    breakdown.purchase = 1.0;
  }

  // 4. AT WORST MATCHING (35% weight) - Same trait = match
  if (guest1.atWorst && guest2.atWorst &&
      guest1.atWorst === guest2.atWorst) {
    breakdown.atWorst = 1.0;
  }

  // 5. SOCIAL STANCE MATCHING (bonus, distance-based)
  // Values: 1=Introverted, 2=Shy, 3=Moderate, 4=Outgoing, 5=Extroverted
  const social1 = parseInt(guest1.socialStance) || 3;
  const social2 = parseInt(guest2.socialStance) || 3;
  const socialDiff = Math.abs(social1 - social2);

  // Perfect match = 1.0, each point apart reduces score
  breakdown.socialStance = Math.max(0, 1 - (socialDiff * 0.25));

  // CALCULATE WEIGHTED CRAM√âR'S V
  const cramersV =
    (breakdown.interests * 0.40) +    // 40% interests
    (breakdown.music * 0.15) +        // 15% music
    (breakdown.purchase * 0.10) +     // 10% purchase
    (breakdown.atWorst * 0.35);       // 35% at worst

  return {
    cramersV: cramersV,
    sharedInterests: sharedInterests,
    breakdown: breakdown
  };
}

/**
 * Helper: Get social stance label
 */
function getSocialStanceLabel(value) {
  const val = parseInt(value);
  if (val === 1) return 'Introverted';
  if (val === 2) return 'Shy';
  if (val === 3) return 'Moderate';
  if (val === 4) return 'Outgoing';
  if (val === 5) return 'Extroverted';
  return 'Unknown';
}

/**
 * Test function - Generate and log compatibility matches
 */
function testCompatibilityMatches() {
  const result = getCompatibilityMatches();

  Logger.log('\n=== COMPATIBILITY MATCHES TEST ===');
  Logger.log(`Total Guests: ${result.totalGuests}`);
  Logger.log(`Matches Found: ${result.matches.length}`);

  if (result.matches.length > 0) {
    Logger.log('\n=== TOP 5 MATCHES ===');
    result.matches.slice(0, 5).forEach((match, idx) => {
      Logger.log(`\n${idx + 1}. ${match.person1.screenName} ‚Üî ${match.person2.screenName}`);
      Logger.log(`   Cram√©r's V: ${(match.similarity * 100).toFixed(1)}%`);
      Logger.log(`   Shared Interests: ${match.sharedInterests.join(', ')}`);
      Logger.log(`   Breakdown:`, match.breakdown);
    });
  }

  return result;
}

// ============================================================================
// PHASE 4: MAP DISPLAY - GUEST ROUTES
// ============================================================================

/**
 * Get guest ZIP codes for map display
 * Returns array of checked-in guests with their ZIP codes
 */
function getGuestZipCodes() {
  Logger.log('=== FETCHING GUEST ZIP CODES FOR MAP ===');

  const guests = getCheckedInGuests();

  const guestZips = guests.map(g => ({
    uid: g.uid,
    screenName: g.screenName,
    zip: g.zip,
    checkInTime: g.checkInTime
  })).filter(g => g.zip && g.zip !== '');

  Logger.log(`Retrieved ${guestZips.length} guests with ZIP codes`);

  return {
    guests: guestZips,
    totalGuests: guestZips.length,
    timestamp: new Date().toISOString()
  };
}

// ============================================================================
// PHASE 5: WALL DATA BACKEND (Merged from WallData.gs)
// ============================================================================

/**
 * Get all data needed for The Wall display
 * Returns: guests, connections by category, unknowns, stats
 */
function getWallData() {
  Logger.log('=== FETCHING WALL DATA ===');

  const guests = getCheckedInGuests();
  Logger.log(`Retrieved ${guests.length} checked-in guests`);

  // Identify unknown guests (don't know hosts)
  const unknownGuests = guests.filter(g => {
    const knowHosts = String(g.knowHosts || '').toLowerCase();
    const knownLongest = String(g.knownLongest || '').toLowerCase();

    return knowHosts.includes('no') ||
           knownLongest.includes('do not know') ||
           knownLongest === '';
  });

  Logger.log(`Found ${unknownGuests.length} unknown guests`);

  // Calculate arrival rate (last 30 min)
  const now = new Date();
  const thirtyMinAgo = new Date(now - 30 * 60 * 1000);
  const recentArrivals = guests.filter(g => {
    const checkInTime = new Date(g.checkInTime);
    return checkInTime > thirtyMinAgo;
  });

  // Format guest data for display
  const formattedGuests = guests.map(g => ({
    uid: g.uid,
    screenName: g.screenName,
    checkInTime: new Date(g.checkInTime).toLocaleTimeString(),
    checkInTimestamp: new Date(g.checkInTime).getTime(),
    photoUrl: g.photoUrl || '',
    isUnknown: unknownGuests.some(u => u.uid === g.uid),

    // Attributes for connection analysis
    age: g.age,
    interests: [g.interest1, g.interest2, g.interest3].filter(Boolean),
    music: g.music,
    zodiac: g.zodiac,
    industry: g.industry,
    education: g.education,
    orientation: g.orientation,
    socialStance: g.socialStance,
    atWorst: g.atWorst
  }));

  // Build connections by category
  const connectionsByCategory = buildConnectionsByCategory(formattedGuests);

  return {
    guests: formattedGuests,
    connectionsByCategory: connectionsByCategory,
    unknownGuests: unknownGuests.map(u => ({
      uid: u.uid,
      screenName: u.screenName
    })),
    stats: {
      totalGuests: guests.length,
      totalUnknowns: unknownGuests.length,
      recentArrivals: recentArrivals.length,
      lastCheckIn: guests.length > 0 ?
        Math.max(...guests.map(g => new Date(g.checkInTime).getTime())) : 0
    }
  };
}

/**
 * Build connections organized by category and subcategory
 * EXCLUDES sexual orientation for privacy
 */
function buildConnectionsByCategory(guests) {
  Logger.log('Building connections by category...');

  const connections = {
    age: buildAgeConnections(guests),
    interests: buildInterestConnections(guests),
    music: buildMusicConnections(guests),
    zodiac: buildZodiacConnections(guests),
    industry: buildIndustryConnections(guests),
    education: buildEducationConnections(guests),
    socialStance: buildSocialStanceConnections(guests)
    // Note: orientation connections excluded for privacy
  };

  return connections;
}

/**
 * Build connections for age groups (by age ranges)
 */
function buildAgeConnections(guests) {
  const ageGroups = {};

  // Helper function to determine age range
  function getAgeRange(age) {
    const ageNum = parseInt(age);
    if (isNaN(ageNum)) return null;

    if (ageNum >= 18 && ageNum <= 20) return 'Age_range_18-20';
    if (ageNum >= 21 && ageNum <= 24) return 'Age_range_21-24';
    if (ageNum >= 25 && ageNum <= 29) return 'Age_range_25-29';
    if (ageNum >= 30 && ageNum <= 34) return 'Age_range_30-34';
    if (ageNum >= 35 && ageNum <= 39) return 'Age_range_35-39';
    if (ageNum >= 40 && ageNum <= 44) return 'Age_range_40-44';
    if (ageNum >= 45) return 'Age_range_45+';

    return null;
  }

  guests.forEach(guest => {
    if (!guest.age) return;

    const ageRange = getAgeRange(guest.age);
    if (!ageRange) return;

    if (!ageGroups[ageRange]) {
      ageGroups[ageRange] = [];
    }
    ageGroups[ageRange].push(guest.uid);
  });

  // Create connections within each age range
  const connections = {};
  Object.keys(ageGroups).forEach(ageRange => {
    const uids = ageGroups[ageRange];
    connections[ageRange] = [];

    // Connect all pairs within the range
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[ageRange].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * Build connections for shared interests
 */
function buildInterestConnections(guests) {
  const interestGroups = {};

  guests.forEach(guest => {
    guest.interests.forEach(interest => {
      if (!interest) return;

      if (!interestGroups[interest]) {
        interestGroups[interest] = [];
      }
      interestGroups[interest].push(guest.uid);
    });
  });

  const connections = {};
  Object.keys(interestGroups).forEach(interest => {
    const uids = interestGroups[interest];
    connections[interest] = [];

    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[interest].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * Build connections for music preferences
 */
function buildMusicConnections(guests) {
  const musicGroups = {};

  guests.forEach(guest => {
    if (!guest.music) return;

    if (!musicGroups[guest.music]) {
      musicGroups[guest.music] = [];
    }
    musicGroups[guest.music].push(guest.uid);
  });

  const connections = {};
  Object.keys(musicGroups).forEach(music => {
    const uids = musicGroups[music];
    connections[music] = [];

    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[music].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * Build connections for zodiac signs
 */
function buildZodiacConnections(guests) {
  const zodiacGroups = {};

  guests.forEach(guest => {
    if (!guest.zodiac) return;

    if (!zodiacGroups[guest.zodiac]) {
      zodiacGroups[guest.zodiac] = [];
    }
    zodiacGroups[guest.zodiac].push(guest.uid);
  });

  const connections = {};
  Object.keys(zodiacGroups).forEach(zodiac => {
    const uids = zodiacGroups[zodiac];
    connections[zodiac] = [];

    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[zodiac].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * Build connections for industries
 */
function buildIndustryConnections(guests) {
  const industryGroups = {};

  guests.forEach(guest => {
    if (!guest.industry) return;

    if (!industryGroups[guest.industry]) {
      industryGroups[guest.industry] = [];
    }
    industryGroups[guest.industry].push(guest.uid);
  });

  const connections = {};
  Object.keys(industryGroups).forEach(industry => {
    const uids = industryGroups[industry];
    connections[industry] = [];

    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[industry].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * Build connections for education levels
 */
function buildEducationConnections(guests) {
  const eduGroups = {};

  guests.forEach(guest => {
    if (!guest.education) return;

    if (!eduGroups[guest.education]) {
      eduGroups[guest.education] = [];
    }
    eduGroups[guest.education].push(guest.uid);
  });

  const connections = {};
  Object.keys(eduGroups).forEach(edu => {
    const uids = eduGroups[edu];
    connections[edu] = [];

    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[edu].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * Build connections for social stance (similar values)
 */
function buildSocialStanceConnections(guests) {
  // Group by ranges: 1-2, 3-4, 5-6, 7-8, 9-10
  const stanceGroups = {
    '1-2': [],
    '3-4': [],
    '5-6': [],
    '7-8': [],
    '9-10': []
  };

  guests.forEach(guest => {
    if (!guest.socialStance) return;

    const stance = parseInt(guest.socialStance);
    if (stance >= 1 && stance <= 2) stanceGroups['1-2'].push(guest.uid);
    else if (stance >= 3 && stance <= 4) stanceGroups['3-4'].push(guest.uid);
    else if (stance >= 5 && stance <= 6) stanceGroups['5-6'].push(guest.uid);
    else if (stance >= 7 && stance <= 8) stanceGroups['7-8'].push(guest.uid);
    else if (stance >= 9 && stance <= 10) stanceGroups['9-10'].push(guest.uid);
  });

  const connections = {};
  Object.keys(stanceGroups).forEach(range => {
    const uids = stanceGroups[range];
    connections[range] = [];

    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[range].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });

  return connections;
}

/**
 * ============================================================================
 * NEXT BUILD PHASES (placeholders):
 * - Phase 3: Analytics layer (Pan_Master, similarity calculations) ‚úì COMPLETED
 * - Phase 4: Visualization endpoints (wall data, compatibility matches) ‚úì COMPLETED
 * - Phase 5: Map display (guest routes to 5317 Charlotte) ‚úì COMPLETED
 * - Phase 6: Wall data backend merged ‚úì COMPLETED
 * - Phase 7: Documentation automation (Master_Desc, Tool_Registry)
 * ============================================================================
 */
